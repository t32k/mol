<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>swiftui on MOL</title>
    <link>https://t32k.me/mol/categories/swiftui/</link>
    <description>Recent content in swiftui on MOL</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 24 Feb 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://t32k.me/mol/categories/swiftui/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SegmentedPickerによるビュー切り替えトランジション</title>
      <link>https://t32k.me/mol/log/segmentedpickerstyle/</link>
      <pubDate>Wed, 24 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://t32k.me/mol/log/segmentedpickerstyle/</guid>
      <description>まぁ題名の通り。
struct ContentView: View { @State private var selection = 0 var body: some View { VStack(spacing:0) { Picker(&amp;#34;&amp;#34;, selection: self.$selection) { Text(&amp;#34;A&amp;#34;).tag(0) Text(&amp;#34;B&amp;#34;).tag(1) }.pickerStyle(SegmentedPickerStyle()).padding() if selection == 0 { viewAlpha } else { viewBeta } } } private var viewAlpha: some View { ZStack { Color(.blue).edgesIgnoringSafeArea(.all) Text(&amp;#34;A&amp;#34;).foregroundColor(.white) } } private var viewBeta: some View { ZStack { Color(.red).edgesIgnoringSafeArea(.all) Text(&amp;#34;B&amp;#34;).foregroundColor(.white) } } } よくあるタブ切り替えのような感じのものをPickerのSegmentedPickerStyleで＠State変数を切り替えることでビューを切り替える。
普通に作ったらこんなかんじで、パッパッと切り替わる。当たり前だ。transitionを指定してないから。
どうするのが自然なんだろうと考えたとき、こんな感じのメンタルモデルだと。
セグメントコントロールを右にスライドしているのだから（A-&amp;gt;B）、それに関連するビューも左から右に出てきてほしいものだ。イメージ的に。なんとなく。たぶん。その逆（B-&amp;gt;A）は右から出て左にいってほしいもの。イメージ的に。なんとなく。たぶん。
VStack { Picker if selection == 0 { viewAlpha .</description>
    </item>
    
    <item>
      <title>SwiftのOptional型とか</title>
      <link>https://t32k.me/mol/log/swift-optional-type/</link>
      <pubDate>Fri, 11 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://t32k.me/mol/log/swift-optional-type/</guid>
      <description>TypeScriptもあんまり使ったことなかったから、型がどうも苦手というか慣れない。 Int とか String とかそうゆうシンプルなものだと分かるが、そのシンプルな型をよくわからないものにするのがOptional型だと苦手意識を持っていた。
var a: String = &amp;#34;swift&amp;#34; var b: String? = nil var c: Optional&amp;lt;String&amp;gt; = nil b と c は書き方が違うだけでどちらもオプショナルString型。まぁnilを許容するかどうかって話なのだが、問題は扱い方。
var foo: Int? = 3 var bar: Int = foo + 1 bar のところでエラーになる。アンラップしろよとかなんとか注意される。
アンラップ（開示） なんでや!! foo に3が代入されとるのは明らかやろ！と思っていたが、アンラップしろと言われているので、とりあえずアンラップしてみる。
var foo: Int? = 3 var bar: Int = foo! + 1 foo は Optional&amp;lt;Int&amp;gt; であって、 Int ではないので、違う型同士で足し算はできない。そこで、オプショナルIntからIntを取り出さなければならない。これをアンラップといい、上記のようにビックリマークをおしりにつける。そうするとちゃんと計算を実行できるようになる。
なんかアンラップしろって言われたら、とりあえずビックリマークつけときゃいいんやなと雑に覚えてしまっっていたので、のちのち困ることになった。
var foo: Int? var bar: Int = foo! + 1 foo に値が代入されていない場合、アンラップしても nil が返ってくるのでエラーになる。</description>
    </item>
    
    <item>
      <title>SwiftUIでのスタイルのまとめかたとか</title>
      <link>https://t32k.me/mol/log/styles-swiftui/</link>
      <pubDate>Thu, 08 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://t32k.me/mol/log/styles-swiftui/</guid>
      <description>CSSだとスタイルはクラスでまとめられ、BEMなり、なんなりのクラスの命名規則で管理する。SwiftUIだとスタイルはViewに繋げられたモディファイアであり、これがダラダラと記述されているのは、見通しが悪い。
struct ContentView: View { var body: some View { Text(&amp;#34;Hello, World!&amp;#34;) .font(.largeTitle) .foregroundColor(Color(.systemRed)) .padding() .frame(maxWidth: .infinity, alignment: .leading) } } カスタムモディファイア modifier というまんまのものがある。上記のコードは LargeText という ViewModifier 定義すると、.modifier(LargeText(color: Color(.systemRed))) だけを View に繋げれば良い。また引数を持つことができるので、色の部分を抜き出して、青色のテキストを表示したり、緑色のテキストを表示できるといった具合だ。
struct ContentView: View { var body: some View { Text(&amp;#34;Hello, World!&amp;#34;) .modifier(LargeText(color: Color(.systemRed))) } } struct LargeText: ViewModifier { let color: Color func body(content: Content) -&amp;gt; some View { content .font(.largeTitle) .foregroundColor(color) .padding() .frame(maxWidth: .infinity, alignment: .leading) } } カスタムスタイル modifier と似ているが、特定のコンポーネントにはカスタムスタイルを定義する方法が提供されている。</description>
    </item>
    
    <item>
      <title>SwiftUIでの色とか</title>
      <link>https://t32k.me/mol/log/color-swiftui/</link>
      <pubDate>Wed, 07 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://t32k.me/mol/log/color-swiftui/</guid>
      <description>UIKitのUIColorとSwiftUIのColorは違うと気づいた最近。
例えば、赤色を表示したいときは、SwiftUIでは Color.red と書く。たまにColor(.red) というのも見かけて、書き方の違いなんだろうか？と思ってたけど、全然違った。Color(.red) は Color(UIColor.red) の略した書き方で、UIColor をSwiftUIのColorとして使う方法だった。
ややこしいのはText(&amp;quot;hoge&amp;quot;).foregroundColor(.red)のようなケース。文字色を赤色にしたいとき、foregroundColorモディファイアはColorが引数に来ると想定しているので、foregroundColor(Color.red)と同じである。もし、UIColorの方の赤を指定したかったら、foregroundColor(Color(.red))と書かなければならない。
ちなみに、赤色としても微妙に違う。
struct ContentView: View { var body: some View { HStack { ZStack { Rectangle().foregroundColor(Color(.red)) Text(&amp;#34;UIColor&amp;#34;).foregroundColor(.white) } ZStack { Rectangle().foregroundColor(Color.red) Text(&amp;#34;SwiftUI&amp;#39;s Color&amp;#34;).foregroundColor(.white) } } } } どうして、気づくの時間がかかったかというと、今作成しているのはモックアプリでシステムカラーしか使ってなかったためである。つまり、Color(. systemRed)のような書き方で統一していたというか、システムカラーはUIColorなので、そう書かざるをえなかった。
システムカラーを使うと、ダークモードのときや、アクセシビリティモードのときに適切な色味に変換してくれるメリットがある。つまり、システムカラーさえ使っとけば、おーるおっけー。やったね 🤗
気をつけなければならないのは、黒や白といったものである。コンポーネントの背景色を白色にしたいと思って、安易に Color.white を使わない。当たり前だがColor.white はダークモードのときも白色だがアプリ全体の背景色は黒色になる。そうしたとき、想定していない見た目になるかもしれな。そうゆうときは Color(.systemBackground)を使うと良い。文字色もColor(.label)を使うと、黒と白が反転して良い感じになる。
濃淡を使い分けたかったら、SystemGrayを使うと良い。
CSSだけど、このブログをダークモードに対応したとき、めんどくさかったんだよなと思い出した。そういう意味では、ダークモードだけでなくアクセシビリティモードのときのカラーセットもはじめから用意してくれているiOS様様である。
 Color - Visual Design - iOS - Human Interface Guidelines - Apple Developer  SwiftUI 徹底入門 金田 浩明 Amazon.co.jpで詳細を見る   </description>
    </item>
    
    <item>
      <title>SwiftUIでの余白のとりかたとか</title>
      <link>https://t32k.me/mol/log/margin-padding-swiftui/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://t32k.me/mol/log/margin-padding-swiftui/</guid>
      <description>Webレイアウトを組むにあたってMargin/Paddingは非常に重要だ。しかし、SwiftUIにおいてPaddingモディファイアはあるがMarginのそれはない。こんなの片腕をもがれた状態じゃないか！と思ったが、SwiftUIでは、どうやら勝手が違うようである。
struct ContentView: View { var body: some View { HStack(spacing: 40) { Text(&amp;#34;タグ１&amp;#34;) .padding() .background(Color.yellow) Text(&amp;#34;タグ2&amp;#34;) .padding() .background(Color.blue) } } } 上記のように、タグのようなものを横並びにしたいと思ったとき、Marginがないので、どこでタグ間の余白を調整すればよいのかと思っていた。とりあえず、親のHStackにspacingプロパティを持つことができるので、ここでMarginの役割をもたせていた。
あとから気づいたが、これは実にWeb的な考え方である。つまりCSSボックスモデルの呪縛からの脱却が必要だ。
 ボックスモデル | MDN　より
 CSSボックスモデルとは上図のように、一番内側にコンテンツがあり次にPaddingとBorder、Marginと広がっていく。なので、一つのCSSセレクタにPadding/Border/Marginのプロパティは１回しか適用できない。この考えが私の頭にこびりついていたのだ。
struct ContentView: View { var body: some View { Text(&amp;#34;コンテンツ&amp;#34;) .padding() .background(Color.yellow) .padding() .border(Color.red, width: 1) .padding() .padding() .border(Color.green, width: 1) .padding() } } 実際のSwiftUIにそんなCSSボックスモデルのような制約はない。Paddingは何回使ってもいいし、Borderも何回でもかけることができる。Borderの次にPaddingを指定すれば、Webで言うMargin的な使い方もできる（青枠はデバッグ用のView表示領域）。
ゆえにスタイリングのためにDIVを何個も入れ子にする必要はないのである。当初はMargin以上にDIV的なViewはないのかな？とよく思ったものであるが、そもそも最初からSwiftUIに必要なかったのである。
struct ContentView: View { var body: some View { VStack { Text(&amp;#34;コンテンツ&amp;#34;) .padding() .</description>
    </item>
    
    <item>
      <title>SwiftUIでの文字寄せとか</title>
      <link>https://t32k.me/mol/log/text-align-swiftui/</link>
      <pubDate>Mon, 28 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://t32k.me/mol/log/text-align-swiftui/</guid>
      <description>最近、SwiftUIデビューをした。太古の昔にTitanium MobileでiOSアプリを作ったことはあるが、基本Web畑で育ってきたt32kにとっては、iOSというかSwiftというかSwiftUIでのユーザーインターフェイス作成は、まるで外国での生活のようで、いろいろカルチャーギャップを感じる。そうゆうことを書きたい。
まず初めに、文字寄せだが、テキストを左寄せ・右寄せにしたいときどうすればよいんだろうと思った。Xcodeでプロジェクトを作成するとHello World!の文字列を表示するボイラープレートが用意されている。
この文字列は上下・左右・真ん中に表示されている。これを左寄せにしたい。Webでいう、text-align: leftは、SwiftUIではどうするんだろうと私は考える。
struct ContentView: View { var body: some View { Text(&amp;#34;Hello, World!&amp;#34;) .frame(alignment: .leading) } } frameモディファイアでaligmentというプロパティがあるのでそれに.leading２セットすればよいらしい。
なるほど。動かない。
それもそのはずだ、Textビューのサイズ（青枠）を見ればわかる。文字でいっぱいいっぱいなので、どちらか片方に寄せれないっぽい。
struct ContentView: View { var body: some View { Text(&amp;#34;Hello, World!&amp;#34;) .frame(maxWidth: .infinity, alignment: .leading) } } Frameのサイズを画面いっぱいにひろげてみると、なるほどな、左に寄せることができた。ちなみに右寄せの場合は.trailingだ。
またStackOveflowでこうゆう回答も見かけた。
struct ContentView: View { var body: some View { VStack { HStack { Text(&amp;#34;Hello, World!&amp;#34;) Spacer() } HStack { Spacer() Text(&amp;#34;Hello, World!&amp;#34;) } } } } Spacer()使うと楽だぜヒャッハーという。これだとSpacer()が目一杯広がるので、frameのwidthを明示的に指定しなくてもいいし楽っぽい。</description>
    </item>
    
  </channel>
</rss>