<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 第5版 7章 オブジェクトと配列 &mdash; MOL</title>
    <link href="http://fonts.googleapis.com/css?family=Droid+Sans:400,700" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/images/logo.png"/>
    <link href="/feed.xml" rel="alternate" type="application/rss+xml" title="MOL" />
    <meta name="title" content="JavaScript 第5版 7章 オブジェクトと配列 ">
    <link rel="canonical" href="http://t32k.me//mol/log/objects-and-arrays">
     
           
    <meta property="og:title" content="JavaScript 第5版 7章 オブジェクトと配列 "/>
    <meta property="og:url" content="http://t32k.me//mol/log/objects-and-arrays"/>
    
    
    <!--meta property="og:description" content="<p>オブジェクトと配列はデータ型<br /><br /><h5>7.1 オブジェクトの生成</h5>オブジェクトとは順序付けされていないプロパティの集合<br />それぞれのプロパティは名前と値を持つ<br /><br />オブジェクトの生成はオブジェクトリテラルが便利<br /><br /><pre>var empty = {}; // 空のオブジェクトを生成<br />var point = { x:0, y:0 };<br />var homer = {<br />　&quot;name&quot; : &quot;Homer Simpson&quot;,<br />　&quot;age&quot; : 34<br />};</pre><br /><br />オブジェクトリテラルは新しいオブジェクトを生成し初期化する式<br />ループ中にオブジェクトリテラルを書くとたくさんのオブジェクトを生成しちゃう<br /><br />new演算子でも生成できる<br /><br /><pre>var a = new Array();<br />var d = new Date();  // 現在の日付と時刻を表すオブジェクトを生成</pre><br /><br /><br /><h5>7.2 オブジェクトのプロパティ</h5>オブジェクトのプロパティにアクセスするにはドット演算子を仕様<br /><br />オブジェクトに評価される式.プロパティの名前<br /><br /><pre>var book = {}; //オブジェクトを生成<br /><br />//オブジェクトのプロパティに値を設定<br />book.title = &quot;javascript - warikiru&quot; ;<br /><br />//オブジェクトの入れ子もＯＫ<br />book.chapter1 = new Object();<br />book.chapter1.title = &quot;Introduction to warikiru&quot;;<br />book.chapter1.pages = 11;<br /><br />//オブジェクトリテラルでもおｋ<br />book.chapter2 = { title: &quot;History of warikiru&quot;, pages: 6};</pre><br /><br />変数はvarキーワードで宣言するけど、プロパティはその必要はない<br />新しい値を代入すればプロパティの値を変更できる<br /><br /><br /><br />オブジェクトプロパティの調査<br /><pre>function display<em>property</em>names(obj) {<br />var names = &quot;&quot;;<br />for(var name in obj) {<br />names += name + &quot;\n&quot;;<br />}<br />alert(names);<br />}</pre><br />指定したオブジェクトのプロパティ名をアラート<br />組み込み系のオブジェクトは調べられないものもある<br /><br />プロパティの存在確認<br />in演算子を使って、プロパティが存在するかどうか調べる<br /><br />in演算子の左側はプロパティの文字列、右側には確認対象となるオブジェクト<br /><br /><pre>//オブジェクトobjがxというプロパティを持つ場合、プロパティに値を設定<br />if(&quot;x&quot; in obj) obj.x =1; </pre><br /><br /><pre>//プロパティがxが存在し、未定義値ではない場合は値を設定<br />if(obj.x !== undefined) obj.x = 1;</pre><br /><br />プロパティの削除<br />delete book.chapter2;<br />プロパティに未定義値が代入されるだけでなく本当に削除される<br /><br /><h5>7.3 連想配列としてのオブジェクト</h5><br /><pre>object.property<br />object[&quot;property&quot;]</pre><br />上記のコードは同じこと<br /><br />配列表記の方が柔軟性が高い<br />なぜなら識別子は静的で文字列は動的でプログラムの実行中に生成することも可能<br /><br />ユーザが株の銘柄と持ち株数を入力した後に株の総額を計算する場合<br /><pre>var value = 0;<br />for (stock in portfolio) {<br />value += get<em>share</em>value(stock) * portfolio[stock];<br />}</pre><br />オブジェクトportfolioのプロパティ名が株の銘柄、値に株数<br />get<em>share</em>value関数で株価を取得<br />このようなオブジェクトの使い方を連想配列とも呼ぶ<br />『文字列（プロパティ名）を値にマップ（関連付け）する』<br /><br /><br /><h5>7.4 Objectのプロパティとメッソド</h5>JSのすべてのオブジェクトはObjectクラスを継承する。<br /><br /><b>constructor プロパティ</b><br />オブジェクトの初期化で使用されたコンストラクタ関数を参照<br /><br /><b>toString() メソッド</b><br />呼び出したオブジェクトの値を表す文字列を返す（引数をとらない）<br /><br /><b>toLocaleString() メソッド</b><br />toString() メソッドと違いがよく分からん＞＜<br /><br /><b>valueOf() メソッド</b><br />指定されたオブジェクトのプリミティブな値を返す（文字列じゃない）<br /><br /><b>hasOwnProperty() メソッド</b><br />呼び出しで使用したオブジェクトが、引数で指定した名前のプロパティ（継承したものではない）を持つ場合はtrueを返す<br /><br /><pre>var o = {};<br />o.hasOwnProperty(&quot;undef&quot;);　//定義されていないのでfalse<br />o.hasOwnProperty(&quot;toString&quot;);　//継承されたプロパティなのでfalse<br />Math.hasOwnProperty(&quot;cos&quot;);　//Mathオブジェクトはcosプロパティを持つのでtrue</pre><br /><br /><b>propertyisEnumerable() メソッド</b><br />呼び出しで使用したオブジェクトが、引数で指定した名前の継承したものではないプロパティを持ち、かつそのプロパティがfor/inループで調べられる場合trueを返す<br /><br /><pre>var o = {x:1};<br />o.propertyisEnumerabl(&quot;x&quot;);　//定義されfor/inループで調べられるのでtrue<br />o.propertyisEnumerabl(&quot;y&quot;);　//存在しないのでfalse<br />o.propertyisEnumerabl(&quot;valueOf&quot;);　//継承されたものなのでfalse</pre><br />あまり使いどこがわからん＞＜<br />英単語【enumerable：可算の】<br /><br /><b>isPrototypeOf() メソッド</b><br />呼び出したオブジェクトが、引数で指定したオブジェクトのプロトタイプオブジェクトである場合にtrueを返す<br /><br /><br /><h5>7.5 配列</h5><b>配列</b>：値を順序付けてまためたもの<br /><b>要素</b>：配列の個々の値<br /><b>インデックス</b>：各要素に割り当てる番号<br /><br />配列の配列なんてこともできる<br /><br />配列リテラルの簡単<br /><pre>var empty = [];  // 空の配列を生成<br />var primes = [2, 3, 5, 7, 11];  // 5個の数値を持つ配列を生成<br />var misc = [ 1.1, true, &#39;a&#39;]　// 3個のさまざまな型の値を持つ配列を生成<br /><br />// 任意の式も記述可能<br />var base = 1024;<br />var table = [base, base+1, base+2];<br /><br />// オブジェクトリテラルやほかの配列リテラルも記述可能<br />var b = [ [1, {x:1, y:2}], [2, {x:3, y:4}]];<br /><br />var count = [1,,3] // 3個の要素の配列、真ん中は未定義<br />var undef = [,,] // 2個の要素をも配列、全部未定義</pre><br /><br />Arrayコンストラクタ<br /><br /><b>引数なしで呼び出す方法</b><br /><pre>var a = new Array();<br />var a = [];</pre><br />上記は同じ意味<br /> <br /><b>配列の要素の値を明示的に指定して呼び出す方法</b><br /><pre>var a = new Array(5, 4, 3, 2, &quot;testing&quot;);</pre><br />この場合、配列リテラルの方が便利<br /><br /><b>1個の数値を引数として指定して呼び出す方法</b><br /><pre>var a = new Array(10);</pre><br />このように記述すると、指定された個数の要素を持つ配列が生成されます。<br />この場合、Arrayコンストラクタの方が便利<br /><br /><h5>7.6配列要素の読み書き</h5><br />配列の先頭要素のインデックスは0<br />配列のインデックスは0以上2の32乗-1未満の整数しか使えない<br />負数、浮動小数点数、論理値、オブジェクトなどをインデックスとして使うと文字列にしてオブジェクトのプロパティとして使う<br /><br />配列の要素の追加<br /><pre>a[0] = 1;<br />a[10000] = &quot;this is element&quot;;</pre><br />この場合、インデックス0と10000の2つの要素だけにメモリを割り当てるだけ<br /><br /><pre>var c = new Circle(1, 2, 3);<br />c[0] = &quot;this is element&quot;;</pre><br />この場合、「0」と言う名前のプロパティをオブジェクトに追加しただけ<br /><br />配列の要素の削除<br />delete演算子を使うと要素に未定義値を設定するだけで要素自体は削除されない<br />削除したい場合、shift(), pop(), splice()メソッドえ使う<br /><br />配列の長さ<br />配列は特別なlengthプロパティを持つ<br />配列に新しい要素が追加されるたびにlengthプロパティも自動的に更新される<br /><pre>var a = new Array(); // a.length == 0<br />a = new Array(10); // a.length == 10<br />a = new Array(1, 2, 3); // a.length == 3<br />a = [4, 5]; // a.length == 2<br />a = [5] = -1;  // a.length == 6<br />a = [49] = 0;  // a.length == 50</pre><br /><br />配列の要素の巡回<br /><pre>var fruits = [&quot;mango&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;pear&quot;];<br />for(var i = 0; i &lt; fruits.length; i++);<br />    alert(fruits[i]);<br />lengthプロパティをよく使う<br /><br />for(var i = 0; i &lt; fruits.length; i++)<br />    if (fruits[i]) alert(fruits[i]);</pre><br />    配列の要素に0から始まる連続した番号が振られていなくて、確かめる場合<br /><br /><pre>var lookup<em>table = new Array(1024);<br />for (var i = 0; i &lt; lookup</em>table.length; i++)<br />    lookup_table[i] = i * 512;</pre><br />このようなループを使えば配列要素の初期化もできる<br /><br />配列の長さの変更<br />現在値より小さな値をlengthプロパティに設定すれば切り詰められる<br />現在値より大きな値を設定すれば指定された長さになるまで未定義値が追加される<br /><br />多次元配列<br />配列の配列を使えばそれっぽいことができる<br /><br /><h5>7.7 配列のメソッド</h5><b>join() メソッド</b><br />配列のすべての要素を文字列に変換し連結する<br />各要素を区切るための文字を指定することも可能<br /><pre>var a = [1, 2, 3];<br />var s = a.join(); // s == &quot;1,2,3&quot;</pre><br /><br />区切り文字は引数で指定<br /><pre>s = a.join(&quot;, &quot;); // s == &quot;1, 2, 3&quot;</pre><br /><br /><b>reverse() メソッド</b><br />配列の要素の順番を逆にするときに使用、既存の配列の中で並べ替え<br /><pre>var a = new Array(1,2,3);<br />a.reverse(); // 並びは(3,2,1)</pre><br /><br /><b>sort() メソッド</b><br />配列の要素をソートするときに使用、既存の配列の中でソート<br />引数をしていないとアルファベット順になる<br />必要に応じて要素を文字列に変換して比較してくれる<br />未定義値は最後にソートされる<br /><br /><pre>var a = [&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;];<br />a.sort(); //  &quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;<br />sort() メソッドの引数には比較関数を指定<br /><br />var a = [33, 4, 1111, 222];<br />a.sort(function(a,b) { //  数値順：4, 33, 222, 1111<br />                        return a-b;<br />                    });</pre><br /><br /><b>concat() メソッド</b><br />配列に要素を追加して新たな配列を生成<br /><pre>var a = [1,2,3];<br />a.concat(4, 5);  // [1, 2, 3, 4, 5]になる<br />a.concat([4, 5], [6, 7]);  // [1, 2, 3, 4, 5, 6, 7]になる</pre><br /><br /><b>slice() メソッド</b><br />指定された配列のサブ配列（スライス）を返す<br />スライス配列には1番目の引数で指定された要素から、2番目の引数で指定された要素（この要素は含まれない）までが格納。引数が1つしか指定されなかった場合、配列の最後の要素までが格納。指定された引数のどちらかが負数の場合、配列の最後からの相対位置で配列の要素が指定されたと解釈。<br /><pre>var a = [1,2,3,4,5];<br />a.slice(0,3); // [1,2,3];<br />a.slice(3); // [4,5];<br />a.slice(1,-1); // [2,3,4];<br />a.slice(-3,-2); // [3];</pre><br /><br /><b>splice() メソッド</b><br />配列に要素を挿入したり、配列から要素を削除したりする汎用的なメソッド<br />slice(), concat()と違って新たに配列を生成しない<br />挿入や削除を開始する位置を１番目の引数で指定、配列から削除する要素の個数を２番目の引数に指定。省略すると最後の要素まで全て削除<br />splice() メソッドを実行すると削除された要素の配列が返る<br /><br /><pre>var a = [1,2,3,4,5,6,7,8];<br />a.splice(4); //  [5,6,7,8]が返され、aは[1,2,3,4]になる<br />a.splice(1,2); //  [2,3]が返され、aは[1,4]になる<br />a.splice(1,1); //  [4]が返され、aは[1]になる</pre><br /><br />3つ目以降の引数は挿入する要素になる<br /><pre>var a = [1,2,3,4,5];<br />a.splice(2,0,&#39;a&#39;,&#39;b&#39;); // []が返され、aは [1,2,&#39;a&#39;,&#39;b&#39;,3,4,5]になる<br />a.splice(2,2,[1,2],3); // [&#39;a&#39;,&#39;b&#39;]が返され、aは [1,2,[1,2],3,3,4,5]になる</pre><br /><br /><b>push() メソッドとpop() メソッド</b><br />push() メソッドは配列の最後に１個または複数の要素を付加し付加したあとの配列の長さを返す<br />pop() メソッド配列の最後の要素を削除し、配列の長さを減らし削除した要素の値を返す<br />どちらも配列そのものを操作する<br /><br /><pre>var stack = [];<br />stack.push(1,2);  // [1,2]　2が返される<br />stack.pop();  // [1]　2が返される<br />stack.push(3);  // [1,3]　2が返される<br />stack.pop();  // [1]　3が返される<br />stack.push([4,5]);  // [1,[4,5]]　2が返される<br />stack.pop();  // [1]　[4,5]が返される<br />stack.pop();  // []　1が返される</pre><br /><br /><b>unshift() メソッドとshift() メソッド</b><br />push() メソッドとpop() メソッドとは逆に先頭の要素を出し入れ<br /><pre>var a = [];<br />a.unshift(1);  // [1]  1が返される<br />a.unshift(22);  // [22,1]  2が返される<br />a.shift();  // [1]  22が返される<br />a.unshift(3,[4,5]);  // [3,[4,5],1]  3が返される<br />a.shift();  // [[4,5],1]  3が返される<br />a.shift();  // [1]  [4,5]が返される<br />a.shift();  // []  1が返される</pre><br /><br /><b>toString() メソッドとtoLocaleString() メソッド</b><br />オブジェクトと同じ配列にもtoString() メソッドあり<br />join() メソッドと一緒、toString() とtoLocaleString()の違いがよくわからん<br /><br /><b>JavaScript1.6で追加されたメソッド</b><br />indexOf(), lastIndexOf(), forEach(), filter()などなど<br /><br /><h5>7.8 配列のようなオブジェクト</h5>配列に新しい要素が追加されると、lengthプロパティが自動的に更新される<br />lengthプロパティに値を設定することで、配列の長さを変更できる<br /><br /><pre>var a = {};<br /><br />//プロパティを追加して『配列』のようにする<br />var i = 0;<br />while(i &lt; 10) {<br /> a[i] = i*i;<br /> i++l<br />}<br />a.length = i;<br /><br />// 通常の配列のようにループを使って要素を利用する<br />var  total = 0;<br />for(var j = 0; j &lt; a.length; j++)<br />total += a[j];</pre><br />lengthプロパティが肝か。。</p>
"/>
    <meta name="description" content="<p>オブジェクトと配列はデータ型<br /><br /><h5>7.1 オブジェクトの生成</h5>オブジェクトとは順序付けされていないプロパティの集合<br />それぞれのプロパティは名前と値を持つ<br /><br />オブジェクトの生成はオブジェクトリテラルが便利<br /><br /><pre>var empty = {}; // 空のオブジェクトを生成<br />var point = { x:0, y:0 };<br />var homer = {<br />　&quot;name&quot; : &quot;Homer Simpson&quot;,<br />　&quot;age&quot; : 34<br />};</pre><br /><br />オブジェクトリテラルは新しいオブジェクトを生成し初期化する式<br />ループ中にオブジェクトリテラルを書くとたくさんのオブジェクトを生成しちゃう<br /><br />new演算子でも生成できる<br /><br /><pre>var a = new Array();<br />var d = new Date();  // 現在の日付と時刻を表すオブジェクトを生成</pre><br /><br /><br /><h5>7.2 オブジェクトのプロパティ</h5>オブジェクトのプロパティにアクセスするにはドット演算子を仕様<br /><br />オブジェクトに評価される式.プロパティの名前<br /><br /><pre>var book = {}; //オブジェクトを生成<br /><br />//オブジェクトのプロパティに値を設定<br />book.title = &quot;javascript - warikiru&quot; ;<br /><br />//オブジェクトの入れ子もＯＫ<br />book.chapter1 = new Object();<br />book.chapter1.title = &quot;Introduction to warikiru&quot;;<br />book.chapter1.pages = 11;<br /><br />//オブジェクトリテラルでもおｋ<br />book.chapter2 = { title: &quot;History of warikiru&quot;, pages: 6};</pre><br /><br />変数はvarキーワードで宣言するけど、プロパティはその必要はない<br />新しい値を代入すればプロパティの値を変更できる<br /><br /><br /><br />オブジェクトプロパティの調査<br /><pre>function display<em>property</em>names(obj) {<br />var names = &quot;&quot;;<br />for(var name in obj) {<br />names += name + &quot;\n&quot;;<br />}<br />alert(names);<br />}</pre><br />指定したオブジェクトのプロパティ名をアラート<br />組み込み系のオブジェクトは調べられないものもある<br /><br />プロパティの存在確認<br />in演算子を使って、プロパティが存在するかどうか調べる<br /><br />in演算子の左側はプロパティの文字列、右側には確認対象となるオブジェクト<br /><br /><pre>//オブジェクトobjがxというプロパティを持つ場合、プロパティに値を設定<br />if(&quot;x&quot; in obj) obj.x =1; </pre><br /><br /><pre>//プロパティがxが存在し、未定義値ではない場合は値を設定<br />if(obj.x !== undefined) obj.x = 1;</pre><br /><br />プロパティの削除<br />delete book.chapter2;<br />プロパティに未定義値が代入されるだけでなく本当に削除される<br /><br /><h5>7.3 連想配列としてのオブジェクト</h5><br /><pre>object.property<br />object[&quot;property&quot;]</pre><br />上記のコードは同じこと<br /><br />配列表記の方が柔軟性が高い<br />なぜなら識別子は静的で文字列は動的でプログラムの実行中に生成することも可能<br /><br />ユーザが株の銘柄と持ち株数を入力した後に株の総額を計算する場合<br /><pre>var value = 0;<br />for (stock in portfolio) {<br />value += get<em>share</em>value(stock) * portfolio[stock];<br />}</pre><br />オブジェクトportfolioのプロパティ名が株の銘柄、値に株数<br />get<em>share</em>value関数で株価を取得<br />このようなオブジェクトの使い方を連想配列とも呼ぶ<br />『文字列（プロパティ名）を値にマップ（関連付け）する』<br /><br /><br /><h5>7.4 Objectのプロパティとメッソド</h5>JSのすべてのオブジェクトはObjectクラスを継承する。<br /><br /><b>constructor プロパティ</b><br />オブジェクトの初期化で使用されたコンストラクタ関数を参照<br /><br /><b>toString() メソッド</b><br />呼び出したオブジェクトの値を表す文字列を返す（引数をとらない）<br /><br /><b>toLocaleString() メソッド</b><br />toString() メソッドと違いがよく分からん＞＜<br /><br /><b>valueOf() メソッド</b><br />指定されたオブジェクトのプリミティブな値を返す（文字列じゃない）<br /><br /><b>hasOwnProperty() メソッド</b><br />呼び出しで使用したオブジェクトが、引数で指定した名前のプロパティ（継承したものではない）を持つ場合はtrueを返す<br /><br /><pre>var o = {};<br />o.hasOwnProperty(&quot;undef&quot;);　//定義されていないのでfalse<br />o.hasOwnProperty(&quot;toString&quot;);　//継承されたプロパティなのでfalse<br />Math.hasOwnProperty(&quot;cos&quot;);　//Mathオブジェクトはcosプロパティを持つのでtrue</pre><br /><br /><b>propertyisEnumerable() メソッド</b><br />呼び出しで使用したオブジェクトが、引数で指定した名前の継承したものではないプロパティを持ち、かつそのプロパティがfor/inループで調べられる場合trueを返す<br /><br /><pre>var o = {x:1};<br />o.propertyisEnumerabl(&quot;x&quot;);　//定義されfor/inループで調べられるのでtrue<br />o.propertyisEnumerabl(&quot;y&quot;);　//存在しないのでfalse<br />o.propertyisEnumerabl(&quot;valueOf&quot;);　//継承されたものなのでfalse</pre><br />あまり使いどこがわからん＞＜<br />英単語【enumerable：可算の】<br /><br /><b>isPrototypeOf() メソッド</b><br />呼び出したオブジェクトが、引数で指定したオブジェクトのプロトタイプオブジェクトである場合にtrueを返す<br /><br /><br /><h5>7.5 配列</h5><b>配列</b>：値を順序付けてまためたもの<br /><b>要素</b>：配列の個々の値<br /><b>インデックス</b>：各要素に割り当てる番号<br /><br />配列の配列なんてこともできる<br /><br />配列リテラルの簡単<br /><pre>var empty = [];  // 空の配列を生成<br />var primes = [2, 3, 5, 7, 11];  // 5個の数値を持つ配列を生成<br />var misc = [ 1.1, true, &#39;a&#39;]　// 3個のさまざまな型の値を持つ配列を生成<br /><br />// 任意の式も記述可能<br />var base = 1024;<br />var table = [base, base+1, base+2];<br /><br />// オブジェクトリテラルやほかの配列リテラルも記述可能<br />var b = [ [1, {x:1, y:2}], [2, {x:3, y:4}]];<br /><br />var count = [1,,3] // 3個の要素の配列、真ん中は未定義<br />var undef = [,,] // 2個の要素をも配列、全部未定義</pre><br /><br />Arrayコンストラクタ<br /><br /><b>引数なしで呼び出す方法</b><br /><pre>var a = new Array();<br />var a = [];</pre><br />上記は同じ意味<br /> <br /><b>配列の要素の値を明示的に指定して呼び出す方法</b><br /><pre>var a = new Array(5, 4, 3, 2, &quot;testing&quot;);</pre><br />この場合、配列リテラルの方が便利<br /><br /><b>1個の数値を引数として指定して呼び出す方法</b><br /><pre>var a = new Array(10);</pre><br />このように記述すると、指定された個数の要素を持つ配列が生成されます。<br />この場合、Arrayコンストラクタの方が便利<br /><br /><h5>7.6配列要素の読み書き</h5><br />配列の先頭要素のインデックスは0<br />配列のインデックスは0以上2の32乗-1未満の整数しか使えない<br />負数、浮動小数点数、論理値、オブジェクトなどをインデックスとして使うと文字列にしてオブジェクトのプロパティとして使う<br /><br />配列の要素の追加<br /><pre>a[0] = 1;<br />a[10000] = &quot;this is element&quot;;</pre><br />この場合、インデックス0と10000の2つの要素だけにメモリを割り当てるだけ<br /><br /><pre>var c = new Circle(1, 2, 3);<br />c[0] = &quot;this is element&quot;;</pre><br />この場合、「0」と言う名前のプロパティをオブジェクトに追加しただけ<br /><br />配列の要素の削除<br />delete演算子を使うと要素に未定義値を設定するだけで要素自体は削除されない<br />削除したい場合、shift(), pop(), splice()メソッドえ使う<br /><br />配列の長さ<br />配列は特別なlengthプロパティを持つ<br />配列に新しい要素が追加されるたびにlengthプロパティも自動的に更新される<br /><pre>var a = new Array(); // a.length == 0<br />a = new Array(10); // a.length == 10<br />a = new Array(1, 2, 3); // a.length == 3<br />a = [4, 5]; // a.length == 2<br />a = [5] = -1;  // a.length == 6<br />a = [49] = 0;  // a.length == 50</pre><br /><br />配列の要素の巡回<br /><pre>var fruits = [&quot;mango&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;pear&quot;];<br />for(var i = 0; i &lt; fruits.length; i++);<br />    alert(fruits[i]);<br />lengthプロパティをよく使う<br /><br />for(var i = 0; i &lt; fruits.length; i++)<br />    if (fruits[i]) alert(fruits[i]);</pre><br />    配列の要素に0から始まる連続した番号が振られていなくて、確かめる場合<br /><br /><pre>var lookup<em>table = new Array(1024);<br />for (var i = 0; i &lt; lookup</em>table.length; i++)<br />    lookup_table[i] = i * 512;</pre><br />このようなループを使えば配列要素の初期化もできる<br /><br />配列の長さの変更<br />現在値より小さな値をlengthプロパティに設定すれば切り詰められる<br />現在値より大きな値を設定すれば指定された長さになるまで未定義値が追加される<br /><br />多次元配列<br />配列の配列を使えばそれっぽいことができる<br /><br /><h5>7.7 配列のメソッド</h5><b>join() メソッド</b><br />配列のすべての要素を文字列に変換し連結する<br />各要素を区切るための文字を指定することも可能<br /><pre>var a = [1, 2, 3];<br />var s = a.join(); // s == &quot;1,2,3&quot;</pre><br /><br />区切り文字は引数で指定<br /><pre>s = a.join(&quot;, &quot;); // s == &quot;1, 2, 3&quot;</pre><br /><br /><b>reverse() メソッド</b><br />配列の要素の順番を逆にするときに使用、既存の配列の中で並べ替え<br /><pre>var a = new Array(1,2,3);<br />a.reverse(); // 並びは(3,2,1)</pre><br /><br /><b>sort() メソッド</b><br />配列の要素をソートするときに使用、既存の配列の中でソート<br />引数をしていないとアルファベット順になる<br />必要に応じて要素を文字列に変換して比較してくれる<br />未定義値は最後にソートされる<br /><br /><pre>var a = [&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;];<br />a.sort(); //  &quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;<br />sort() メソッドの引数には比較関数を指定<br /><br />var a = [33, 4, 1111, 222];<br />a.sort(function(a,b) { //  数値順：4, 33, 222, 1111<br />                        return a-b;<br />                    });</pre><br /><br /><b>concat() メソッド</b><br />配列に要素を追加して新たな配列を生成<br /><pre>var a = [1,2,3];<br />a.concat(4, 5);  // [1, 2, 3, 4, 5]になる<br />a.concat([4, 5], [6, 7]);  // [1, 2, 3, 4, 5, 6, 7]になる</pre><br /><br /><b>slice() メソッド</b><br />指定された配列のサブ配列（スライス）を返す<br />スライス配列には1番目の引数で指定された要素から、2番目の引数で指定された要素（この要素は含まれない）までが格納。引数が1つしか指定されなかった場合、配列の最後の要素までが格納。指定された引数のどちらかが負数の場合、配列の最後からの相対位置で配列の要素が指定されたと解釈。<br /><pre>var a = [1,2,3,4,5];<br />a.slice(0,3); // [1,2,3];<br />a.slice(3); // [4,5];<br />a.slice(1,-1); // [2,3,4];<br />a.slice(-3,-2); // [3];</pre><br /><br /><b>splice() メソッド</b><br />配列に要素を挿入したり、配列から要素を削除したりする汎用的なメソッド<br />slice(), concat()と違って新たに配列を生成しない<br />挿入や削除を開始する位置を１番目の引数で指定、配列から削除する要素の個数を２番目の引数に指定。省略すると最後の要素まで全て削除<br />splice() メソッドを実行すると削除された要素の配列が返る<br /><br /><pre>var a = [1,2,3,4,5,6,7,8];<br />a.splice(4); //  [5,6,7,8]が返され、aは[1,2,3,4]になる<br />a.splice(1,2); //  [2,3]が返され、aは[1,4]になる<br />a.splice(1,1); //  [4]が返され、aは[1]になる</pre><br /><br />3つ目以降の引数は挿入する要素になる<br /><pre>var a = [1,2,3,4,5];<br />a.splice(2,0,&#39;a&#39;,&#39;b&#39;); // []が返され、aは [1,2,&#39;a&#39;,&#39;b&#39;,3,4,5]になる<br />a.splice(2,2,[1,2],3); // [&#39;a&#39;,&#39;b&#39;]が返され、aは [1,2,[1,2],3,3,4,5]になる</pre><br /><br /><b>push() メソッドとpop() メソッド</b><br />push() メソッドは配列の最後に１個または複数の要素を付加し付加したあとの配列の長さを返す<br />pop() メソッド配列の最後の要素を削除し、配列の長さを減らし削除した要素の値を返す<br />どちらも配列そのものを操作する<br /><br /><pre>var stack = [];<br />stack.push(1,2);  // [1,2]　2が返される<br />stack.pop();  // [1]　2が返される<br />stack.push(3);  // [1,3]　2が返される<br />stack.pop();  // [1]　3が返される<br />stack.push([4,5]);  // [1,[4,5]]　2が返される<br />stack.pop();  // [1]　[4,5]が返される<br />stack.pop();  // []　1が返される</pre><br /><br /><b>unshift() メソッドとshift() メソッド</b><br />push() メソッドとpop() メソッドとは逆に先頭の要素を出し入れ<br /><pre>var a = [];<br />a.unshift(1);  // [1]  1が返される<br />a.unshift(22);  // [22,1]  2が返される<br />a.shift();  // [1]  22が返される<br />a.unshift(3,[4,5]);  // [3,[4,5],1]  3が返される<br />a.shift();  // [[4,5],1]  3が返される<br />a.shift();  // [1]  [4,5]が返される<br />a.shift();  // []  1が返される</pre><br /><br /><b>toString() メソッドとtoLocaleString() メソッド</b><br />オブジェクトと同じ配列にもtoString() メソッドあり<br />join() メソッドと一緒、toString() とtoLocaleString()の違いがよくわからん<br /><br /><b>JavaScript1.6で追加されたメソッド</b><br />indexOf(), lastIndexOf(), forEach(), filter()などなど<br /><br /><h5>7.8 配列のようなオブジェクト</h5>配列に新しい要素が追加されると、lengthプロパティが自動的に更新される<br />lengthプロパティに値を設定することで、配列の長さを変更できる<br /><br /><pre>var a = {};<br /><br />//プロパティを追加して『配列』のようにする<br />var i = 0;<br />while(i &lt; 10) {<br /> a[i] = i*i;<br /> i++l<br />}<br />a.length = i;<br /><br />// 通常の配列のようにループを使って要素を利用する<br />var  total = 0;<br />for(var j = 0; j &lt; a.length; j++)<br />total += a[j];</pre><br />lengthプロパティが肝か。。</p>
"/-->
    
    <meta property="og:site_name" content="MOL">     
</head>
<body>
    
<section class="site-nav">
    <header>
        <nav id="navigation">
            <a class="brand" href="/">
                <img src="/images/logo.png" alt="Inc">
            </a>
            <a href="/" class="home">Blog</a>
            <a href="https://github.com/t32k/maple">Maple</a>
            <a href="https://github.com/t32k/t32k.github.io/blob/master/README.md">About</a>
        </nav>
    </header>
</section>


<article>

    <div class="container">
        <header>
            <div class="meta">
                By <address><a rel="author" href="" title="" target="_blank"></a> &mdash;
                <time pubdate datetime="2009-18-May" title="May 18, 2009">May 18, 2009</time>
            </div>
            <h1 class="title">JavaScript 第5版 7章 オブジェクトと配列</h1>
            
        </header>

        <section>
            <p>オブジェクトと配列はデータ型<br /><br /><h5>7.1 オブジェクトの生成</h5>オブジェクトとは順序付けされていないプロパティの集合<br />それぞれのプロパティは名前と値を持つ<br /><br />オブジェクトの生成はオブジェクトリテラルが便利<br /><br /><pre>var empty = {}; // 空のオブジェクトを生成<br />var point = { x:0, y:0 };<br />var homer = {<br />　&quot;name&quot; : &quot;Homer Simpson&quot;,<br />　&quot;age&quot; : 34<br />};</pre><br /><br />オブジェクトリテラルは新しいオブジェクトを生成し初期化する式<br />ループ中にオブジェクトリテラルを書くとたくさんのオブジェクトを生成しちゃう<br /><br />new演算子でも生成できる<br /><br /><pre>var a = new Array();<br />var d = new Date();  // 現在の日付と時刻を表すオブジェクトを生成</pre><br /><br /><br /><h5>7.2 オブジェクトのプロパティ</h5>オブジェクトのプロパティにアクセスするにはドット演算子を仕様<br /><br />オブジェクトに評価される式.プロパティの名前<br /><br /><pre>var book = {}; //オブジェクトを生成<br /><br />//オブジェクトのプロパティに値を設定<br />book.title = &quot;javascript - warikiru&quot; ;<br /><br />//オブジェクトの入れ子もＯＫ<br />book.chapter1 = new Object();<br />book.chapter1.title = &quot;Introduction to warikiru&quot;;<br />book.chapter1.pages = 11;<br /><br />//オブジェクトリテラルでもおｋ<br />book.chapter2 = { title: &quot;History of warikiru&quot;, pages: 6};</pre><br /><br />変数はvarキーワードで宣言するけど、プロパティはその必要はない<br />新しい値を代入すればプロパティの値を変更できる<br /><br /><br /><br />オブジェクトプロパティの調査<br /><pre>function display<em>property</em>names(obj) {<br />var names = &quot;&quot;;<br />for(var name in obj) {<br />names += name + &quot;\n&quot;;<br />}<br />alert(names);<br />}</pre><br />指定したオブジェクトのプロパティ名をアラート<br />組み込み系のオブジェクトは調べられないものもある<br /><br />プロパティの存在確認<br />in演算子を使って、プロパティが存在するかどうか調べる<br /><br />in演算子の左側はプロパティの文字列、右側には確認対象となるオブジェクト<br /><br /><pre>//オブジェクトobjがxというプロパティを持つ場合、プロパティに値を設定<br />if(&quot;x&quot; in obj) obj.x =1; </pre><br /><br /><pre>//プロパティがxが存在し、未定義値ではない場合は値を設定<br />if(obj.x !== undefined) obj.x = 1;</pre><br /><br />プロパティの削除<br />delete book.chapter2;<br />プロパティに未定義値が代入されるだけでなく本当に削除される<br /><br /><h5>7.3 連想配列としてのオブジェクト</h5><br /><pre>object.property<br />object[&quot;property&quot;]</pre><br />上記のコードは同じこと<br /><br />配列表記の方が柔軟性が高い<br />なぜなら識別子は静的で文字列は動的でプログラムの実行中に生成することも可能<br /><br />ユーザが株の銘柄と持ち株数を入力した後に株の総額を計算する場合<br /><pre>var value = 0;<br />for (stock in portfolio) {<br />value += get<em>share</em>value(stock) * portfolio[stock];<br />}</pre><br />オブジェクトportfolioのプロパティ名が株の銘柄、値に株数<br />get<em>share</em>value関数で株価を取得<br />このようなオブジェクトの使い方を連想配列とも呼ぶ<br />『文字列（プロパティ名）を値にマップ（関連付け）する』<br /><br /><br /><h5>7.4 Objectのプロパティとメッソド</h5>JSのすべてのオブジェクトはObjectクラスを継承する。<br /><br /><b>constructor プロパティ</b><br />オブジェクトの初期化で使用されたコンストラクタ関数を参照<br /><br /><b>toString() メソッド</b><br />呼び出したオブジェクトの値を表す文字列を返す（引数をとらない）<br /><br /><b>toLocaleString() メソッド</b><br />toString() メソッドと違いがよく分からん＞＜<br /><br /><b>valueOf() メソッド</b><br />指定されたオブジェクトのプリミティブな値を返す（文字列じゃない）<br /><br /><b>hasOwnProperty() メソッド</b><br />呼び出しで使用したオブジェクトが、引数で指定した名前のプロパティ（継承したものではない）を持つ場合はtrueを返す<br /><br /><pre>var o = {};<br />o.hasOwnProperty(&quot;undef&quot;);　//定義されていないのでfalse<br />o.hasOwnProperty(&quot;toString&quot;);　//継承されたプロパティなのでfalse<br />Math.hasOwnProperty(&quot;cos&quot;);　//Mathオブジェクトはcosプロパティを持つのでtrue</pre><br /><br /><b>propertyisEnumerable() メソッド</b><br />呼び出しで使用したオブジェクトが、引数で指定した名前の継承したものではないプロパティを持ち、かつそのプロパティがfor/inループで調べられる場合trueを返す<br /><br /><pre>var o = {x:1};<br />o.propertyisEnumerabl(&quot;x&quot;);　//定義されfor/inループで調べられるのでtrue<br />o.propertyisEnumerabl(&quot;y&quot;);　//存在しないのでfalse<br />o.propertyisEnumerabl(&quot;valueOf&quot;);　//継承されたものなのでfalse</pre><br />あまり使いどこがわからん＞＜<br />英単語【enumerable：可算の】<br /><br /><b>isPrototypeOf() メソッド</b><br />呼び出したオブジェクトが、引数で指定したオブジェクトのプロトタイプオブジェクトである場合にtrueを返す<br /><br /><br /><h5>7.5 配列</h5><b>配列</b>：値を順序付けてまためたもの<br /><b>要素</b>：配列の個々の値<br /><b>インデックス</b>：各要素に割り当てる番号<br /><br />配列の配列なんてこともできる<br /><br />配列リテラルの簡単<br /><pre>var empty = [];  // 空の配列を生成<br />var primes = [2, 3, 5, 7, 11];  // 5個の数値を持つ配列を生成<br />var misc = [ 1.1, true, &#39;a&#39;]　// 3個のさまざまな型の値を持つ配列を生成<br /><br />// 任意の式も記述可能<br />var base = 1024;<br />var table = [base, base+1, base+2];<br /><br />// オブジェクトリテラルやほかの配列リテラルも記述可能<br />var b = [ [1, {x:1, y:2}], [2, {x:3, y:4}]];<br /><br />var count = [1,,3] // 3個の要素の配列、真ん中は未定義<br />var undef = [,,] // 2個の要素をも配列、全部未定義</pre><br /><br />Arrayコンストラクタ<br /><br /><b>引数なしで呼び出す方法</b><br /><pre>var a = new Array();<br />var a = [];</pre><br />上記は同じ意味<br /> <br /><b>配列の要素の値を明示的に指定して呼び出す方法</b><br /><pre>var a = new Array(5, 4, 3, 2, &quot;testing&quot;);</pre><br />この場合、配列リテラルの方が便利<br /><br /><b>1個の数値を引数として指定して呼び出す方法</b><br /><pre>var a = new Array(10);</pre><br />このように記述すると、指定された個数の要素を持つ配列が生成されます。<br />この場合、Arrayコンストラクタの方が便利<br /><br /><h5>7.6配列要素の読み書き</h5><br />配列の先頭要素のインデックスは0<br />配列のインデックスは0以上2の32乗-1未満の整数しか使えない<br />負数、浮動小数点数、論理値、オブジェクトなどをインデックスとして使うと文字列にしてオブジェクトのプロパティとして使う<br /><br />配列の要素の追加<br /><pre>a[0] = 1;<br />a[10000] = &quot;this is element&quot;;</pre><br />この場合、インデックス0と10000の2つの要素だけにメモリを割り当てるだけ<br /><br /><pre>var c = new Circle(1, 2, 3);<br />c[0] = &quot;this is element&quot;;</pre><br />この場合、「0」と言う名前のプロパティをオブジェクトに追加しただけ<br /><br />配列の要素の削除<br />delete演算子を使うと要素に未定義値を設定するだけで要素自体は削除されない<br />削除したい場合、shift(), pop(), splice()メソッドえ使う<br /><br />配列の長さ<br />配列は特別なlengthプロパティを持つ<br />配列に新しい要素が追加されるたびにlengthプロパティも自動的に更新される<br /><pre>var a = new Array(); // a.length == 0<br />a = new Array(10); // a.length == 10<br />a = new Array(1, 2, 3); // a.length == 3<br />a = [4, 5]; // a.length == 2<br />a = [5] = -1;  // a.length == 6<br />a = [49] = 0;  // a.length == 50</pre><br /><br />配列の要素の巡回<br /><pre>var fruits = [&quot;mango&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;pear&quot;];<br />for(var i = 0; i &lt; fruits.length; i++);<br />    alert(fruits[i]);<br />lengthプロパティをよく使う<br /><br />for(var i = 0; i &lt; fruits.length; i++)<br />    if (fruits[i]) alert(fruits[i]);</pre><br />    配列の要素に0から始まる連続した番号が振られていなくて、確かめる場合<br /><br /><pre>var lookup<em>table = new Array(1024);<br />for (var i = 0; i &lt; lookup</em>table.length; i++)<br />    lookup_table[i] = i * 512;</pre><br />このようなループを使えば配列要素の初期化もできる<br /><br />配列の長さの変更<br />現在値より小さな値をlengthプロパティに設定すれば切り詰められる<br />現在値より大きな値を設定すれば指定された長さになるまで未定義値が追加される<br /><br />多次元配列<br />配列の配列を使えばそれっぽいことができる<br /><br /><h5>7.7 配列のメソッド</h5><b>join() メソッド</b><br />配列のすべての要素を文字列に変換し連結する<br />各要素を区切るための文字を指定することも可能<br /><pre>var a = [1, 2, 3];<br />var s = a.join(); // s == &quot;1,2,3&quot;</pre><br /><br />区切り文字は引数で指定<br /><pre>s = a.join(&quot;, &quot;); // s == &quot;1, 2, 3&quot;</pre><br /><br /><b>reverse() メソッド</b><br />配列の要素の順番を逆にするときに使用、既存の配列の中で並べ替え<br /><pre>var a = new Array(1,2,3);<br />a.reverse(); // 並びは(3,2,1)</pre><br /><br /><b>sort() メソッド</b><br />配列の要素をソートするときに使用、既存の配列の中でソート<br />引数をしていないとアルファベット順になる<br />必要に応じて要素を文字列に変換して比較してくれる<br />未定義値は最後にソートされる<br /><br /><pre>var a = [&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;];<br />a.sort(); //  &quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;<br />sort() メソッドの引数には比較関数を指定<br /><br />var a = [33, 4, 1111, 222];<br />a.sort(function(a,b) { //  数値順：4, 33, 222, 1111<br />                        return a-b;<br />                    });</pre><br /><br /><b>concat() メソッド</b><br />配列に要素を追加して新たな配列を生成<br /><pre>var a = [1,2,3];<br />a.concat(4, 5);  // [1, 2, 3, 4, 5]になる<br />a.concat([4, 5], [6, 7]);  // [1, 2, 3, 4, 5, 6, 7]になる</pre><br /><br /><b>slice() メソッド</b><br />指定された配列のサブ配列（スライス）を返す<br />スライス配列には1番目の引数で指定された要素から、2番目の引数で指定された要素（この要素は含まれない）までが格納。引数が1つしか指定されなかった場合、配列の最後の要素までが格納。指定された引数のどちらかが負数の場合、配列の最後からの相対位置で配列の要素が指定されたと解釈。<br /><pre>var a = [1,2,3,4,5];<br />a.slice(0,3); // [1,2,3];<br />a.slice(3); // [4,5];<br />a.slice(1,-1); // [2,3,4];<br />a.slice(-3,-2); // [3];</pre><br /><br /><b>splice() メソッド</b><br />配列に要素を挿入したり、配列から要素を削除したりする汎用的なメソッド<br />slice(), concat()と違って新たに配列を生成しない<br />挿入や削除を開始する位置を１番目の引数で指定、配列から削除する要素の個数を２番目の引数に指定。省略すると最後の要素まで全て削除<br />splice() メソッドを実行すると削除された要素の配列が返る<br /><br /><pre>var a = [1,2,3,4,5,6,7,8];<br />a.splice(4); //  [5,6,7,8]が返され、aは[1,2,3,4]になる<br />a.splice(1,2); //  [2,3]が返され、aは[1,4]になる<br />a.splice(1,1); //  [4]が返され、aは[1]になる</pre><br /><br />3つ目以降の引数は挿入する要素になる<br /><pre>var a = [1,2,3,4,5];<br />a.splice(2,0,&#39;a&#39;,&#39;b&#39;); // []が返され、aは [1,2,&#39;a&#39;,&#39;b&#39;,3,4,5]になる<br />a.splice(2,2,[1,2],3); // [&#39;a&#39;,&#39;b&#39;]が返され、aは [1,2,[1,2],3,3,4,5]になる</pre><br /><br /><b>push() メソッドとpop() メソッド</b><br />push() メソッドは配列の最後に１個または複数の要素を付加し付加したあとの配列の長さを返す<br />pop() メソッド配列の最後の要素を削除し、配列の長さを減らし削除した要素の値を返す<br />どちらも配列そのものを操作する<br /><br /><pre>var stack = [];<br />stack.push(1,2);  // [1,2]　2が返される<br />stack.pop();  // [1]　2が返される<br />stack.push(3);  // [1,3]　2が返される<br />stack.pop();  // [1]　3が返される<br />stack.push([4,5]);  // [1,[4,5]]　2が返される<br />stack.pop();  // [1]　[4,5]が返される<br />stack.pop();  // []　1が返される</pre><br /><br /><b>unshift() メソッドとshift() メソッド</b><br />push() メソッドとpop() メソッドとは逆に先頭の要素を出し入れ<br /><pre>var a = [];<br />a.unshift(1);  // [1]  1が返される<br />a.unshift(22);  // [22,1]  2が返される<br />a.shift();  // [1]  22が返される<br />a.unshift(3,[4,5]);  // [3,[4,5],1]  3が返される<br />a.shift();  // [[4,5],1]  3が返される<br />a.shift();  // [1]  [4,5]が返される<br />a.shift();  // []  1が返される</pre><br /><br /><b>toString() メソッドとtoLocaleString() メソッド</b><br />オブジェクトと同じ配列にもtoString() メソッドあり<br />join() メソッドと一緒、toString() とtoLocaleString()の違いがよくわからん<br /><br /><b>JavaScript1.6で追加されたメソッド</b><br />indexOf(), lastIndexOf(), forEach(), filter()などなど<br /><br /><h5>7.8 配列のようなオブジェクト</h5>配列に新しい要素が追加されると、lengthプロパティが自動的に更新される<br />lengthプロパティに値を設定することで、配列の長さを変更できる<br /><br /><pre>var a = {};<br /><br />//プロパティを追加して『配列』のようにする<br />var i = 0;<br />while(i &lt; 10) {<br /> a[i] = i*i;<br /> i++l<br />}<br />a.length = i;<br /><br />// 通常の配列のようにループを使って要素を利用する<br />var  total = 0;<br />for(var j = 0; j &lt; a.length; j++)<br />total += a[j];</pre><br />lengthプロパティが肝か。。</p>

            
<div class="social">
    <div>
        <a href="https://twitter.com/share" class="twitter-share-button"  data-text="JavaScript 第5版 7章 オブジェクトと配列" data-related="t32k">Tweet</a>
    </div>
    
    
    <div>
        <div class="fb-like" data-width="150" data-layout="button_count" data-action="like" data-show-faces="true" data-send="false"></div>
    </div>
    
    
    <div>
        <div class="g-plusone" data-size="medium"></div>
    </div>
    
    
</div>

        </section>

        <footer>
            <address>
               
                <p>Written by <strong><a rel="author" href="https://twitter.com/" title="" target="_blank"></a></strong><br>
                <span class="muted"></span>
                </p>
            </address>

        </footer>

        
    </div>
</article>

<footer class="site-footer">
    <div class="container">
        &copy; 2013 
        
        <nav>
            <a href="http://t32k.me/">MOL</a> &middot;
            <a href="/">Blog</a> &middot;
            <a href="https://github.com/t32k/maple">Maple</a> &middot; 
            <a href="https://github.com/t32k/t32k.github.io/blob/master/README.md">About</a>
        </nav>
        
        <nav class="social">
            
            <a href="https://twitter.com/t32k" title="Follow on Twitter" target="_blank"><i class="icon icon-twitter black"></i></a>
            
            
            <a href="http://facebook.com/t32k" title="Follow on Facebook" target="_blank"><i class="icon icon-facebook black"></i></a>
                
            <a href="/feed.xml" title="RSS Feed">
                <i class="icon icon-rss black"></i>
            </a>
        </nav>
        <p>Incorporated theme by <a href="https://sendtoinc.com">Inc</a></p>
    </div>
</footer>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script src="/assets/main.js"></script>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=253595308025739";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>



</body>
</html>