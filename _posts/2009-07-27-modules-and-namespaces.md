---
layout: post
title: JavaScript 第5版 10章 モジュールと名前空間
categories:
- javascript
tags: []
status: publish
type: post
published: true
meta:
  blogger_blog: warikiru.blogspot.com
  blogger_author: t32khttp://www.blogger.com/profile/06797489791220082722noreply@blogger.com
  blogger_permalink: /2009/07/modules-and-namespaces.html
  _edit_last: '1'
  pvc_views: '4470'
---
JSAN (JavaScript Archive Network)、PerlのCPANみたいなもの
JSの言語仕様では、モジュールを作成、管理する機構がない
名前の衝突が起こらないように名前空間を使用することが重要
<h2>10.1 モジュールと名前空間の生成</h2>
「グローバル変数を定義しない」ことが最も重要なルール
<pre>
//名前空間用に空のオブジェクトを生成する
//この１つのグローバルシンボルの中に他のシンボルすべて格納する
var Class = {};

//この名前空間内に関数を定義する
Class.define = function(data) {/* コード */}
Class.provides = function(o, c) {/* コード */}</pre>
モジュールがグローバルな名前空間にシンボルを追加する場合は、最大でも１つにすべきである
<ul>
	<li>モジュールがグローバルな名前空間にシンボルを追加する場合は、どのシンボルを追加するのかをドキュメントに明記する</li>
	<li>モジュールがグローバルな名前空間にシンボルを追加する場合は、シンボル名とモジュールのファイル名に明確な関係を持たせる</li>
</ul>
<pre>
/* hogehoge/Class.js */
var hogehgoe;

// hogehogeグルーバルシンボルを宣言
if(!hogehoge) hogehoge = {}; 

// 未定義の場合、オブジェクトを代入
hogehoge.Class = {};

// hogehoge.Class名前空間を生成
// そして、この名前空間に関数を追加していく</pre>
hogehogeグローバルオブジェクトは名前空間のための名前空間オブジェクト
２段階の名前空間を使用することで名前の衝突の可能性を減らすことができる
例えばt32k.meならme.t32k.Classと言う名前空間なら衝突をおこさない
つまり、所有していないドメインを逆さまにした名前空間を定義しないということ
ちょっとやりすぎ感はあるがこうゆう例もあるということ
<h3>10.1.1 モジュールの可用性のチェック</h3>
モジュールの名前空間のVERSIONのプロパティにモジュールのバージョン番号を格納するようにしておけば、モジュールが存在するかどうかだけでなく、ある特定のバージョンのモジュールが存在するかどうかも調べられる
<h3>10.1.2 モジュールとしてのクラス</h3>
先ほどの「Class」モジュールはユーティリティ関数をまとめたものだけど、
関数１つだけでもいいし、クラスでもかまわなくて、特に形式はない
<h3>10.1.3 モジュール初期化コード</h3>
匿名関数中にコードを記述し、すぐ実行することでグローバルな名前空間汚さない
<pre>
(function() {
  //匿名関数を定義。名前がないのでグローバルシンボルも追加しない
  //ここにコードを記述
  //関数中なのでどんな名前の変数も安全に利用できる
  //結局グローバルシンボルは１つも生成されない
})(); 　//関数定義が完了したのですぐに呼び出す
</pre>
モジュール読み込み時に初期化が必要なもの、読み込んだ後に何らかのタイミングで初期化が必要なもの
クライアントサイドJavaScriptでは後者が一般的
モジュールを自己完結型にできれば、HTMLにJSコードを記述しなくて控えめである（unobtrusive JavaScript）
<h2>10.2 名前空間からのシンボルのインポート</h2>
com.warikiru.Classなど一意の名前空間を使用すると関数名が長くなっちゃう
別の変数に入れて入力を楽にする
<pre>var define = me.t32k.Class.define;</pre>
ただこれだと何が定義（define）されるのか分からないので、変更してみる
<pre>var defineClass = me.t32k.Class.define;</pre>
しかし、メソッド名を変更するのはあまりよくない。
<pre>
//単純な名前空間を生成
var Class = {};

//この名前空間にシンボルをインポート
Class.define = me.t32k.Class.define;</pre>
この場合、インボートできるシンボルは、関数やオブジェクト、配列を参照しているものだけである
数値や文字列のような基本型の値を持つシンボルをインポートした場合は単にコピーしているだけ
インポートはモジュール利用者側のためのものである
つまり、モジュール開発者は常に、シンボルの完全修飾名を使わなければならない
<h3>10.2.1 パブリックシンボルとプライベートシンボル</h3>
モジュールの名前空間中で定義されているシンボルがすべて外部から使用されることを意図していない
モジュール専用の内部関数や変数を持つ場合もあり、このようなものはあまり触れて欲しくない
モジュールのプライベートプロパティを明示する方法
<ul>
	<li>ドキュメントに記述</li>
	<li>プライベートなシンボルはアンダースコア(_)から始めるようにする</li>
</ul>
<h3>10.2.2 プライベートな名前空間とスコープとしてのクロージャ</h3>
クロージャがまだ理解していないのでわかりません＞＜
<h2>10.3 モジュールユーティリティ</h2>
便利なサンプルコードが載ってます。。。
